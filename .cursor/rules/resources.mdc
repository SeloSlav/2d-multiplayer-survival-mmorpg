---
description: 
globs: 
alwaysApply: false
---
# Guide: Adding New Collectible Resources (Streamlined)

This guide provides a systematic approach to adding new collectible resources (like Common Reed Stalk, Hemp, Corn, etc.) to the 2D Multiplayer Survival game. This workflow was tested and refined during the Common Reed Stalk implementation.

## Quick Reference Checklist

### Server-side (3 files)
- [ ] Create `server/src/{resource_name}.rs` 
- [ ] Update `server/src/lib.rs` (2 lines)
- [ ] Update `server/src/environment.rs` (seeding + respawn)

### Client-side (10 files)  
- [ ] Update `client/src/types/resourceTypes.ts` (type guards)
- [ ] Update `client/src/utils/renderers/resourceConfigurations.ts` (config)
- [ ] Update `client/src/utils/renderers/unifiedResourceRenderer.ts` (render function)
- [ ] Update `client/src/utils/renderers/renderingUtils.ts` (rendering integration)
- [ ] Update `client/src/hooks/useSpacetimeTables.ts` (subscriptions)
- [ ] Update `client/src/App.tsx` (data flow)
- [ ] Update `client/src/components/GameScreen.tsx` (data flow)
- [ ] Update `client/src/components/GameCanvas.tsx` (data flow)
- [ ] Update `client/src/hooks/useEntityFiltering.ts` (filtering)
- [ ] Update `client/src/utils/typeGuards.ts` (type detection)
- [ ] Update `client/src/hooks/useInteractionFinder.ts` (interaction detection)
- [ ] Update `client/src/hooks/useInputHandler.ts` (E key handling)
- [ ] Update `client/src/utils/renderers/labelRenderingUtils.ts` (interaction labels)

---

## Detailed Implementation Steps

### Step 1: Server-side Implementation

#### 1.1 Create Resource Module (`server/src/{resource_name}.rs`)

Create a new file following this exact pattern:

```rust
/******************************************************************************
 *                                                                            *
 * Defines the {resource_name} resource system including spawning,           *
 * collection, and respawning mechanics. {Resource_Name}s are a material     *
 * resource that can be picked directly without tools.                       *
 *                                                                            *
 ******************************************************************************/

// SpacetimeDB imports
use spacetimedb::{Table, ReducerContext, Identity, Timestamp};
use log;
use rand::Rng;
use crate::TILE_SIZE_PX;

// Module imports
use crate::collectible_resources::{
    validate_player_resource_interaction, 
    collect_resource_and_schedule_respawn, 
    BASE_RESOURCE_RADIUS, 
    PLAYER_RESOURCE_INTERACTION_DISTANCE_SQUARED
};

#[spacetimedb::table(name = {resource_name}, public)]
#[derive(Clone, Debug)]
pub struct {ResourceName} {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub pos_x: f32,
    pub pos_y: f32,
    pub chunk_index: u32,
    pub respawn_at: Option<Timestamp>,
}

// --- Constants ---
pub const {RESOURCE_NAME}_YIELD_ITEM_NAME: &str = "{Item Display Name}";
pub const {RESOURCE_NAME}_YIELD_AMOUNT_MIN: u32 = 2;
pub const {RESOURCE_NAME}_YIELD_AMOUNT_MAX: u32 = 4;
pub const {RESOURCE_NAME}_SECONDARY_ITEM_NAME: &str = "Plant Fiber"; // Optional secondary yield
pub const {RESOURCE_NAME}_SECONDARY_AMOUNT_MIN: u32 = 1;
pub const {RESOURCE_NAME}_SECONDARY_AMOUNT_MAX: u32 = 3;
pub const {RESOURCE_NAME}_SECONDARY_CHANCE: f32 = 0.75; // 75% chance
pub const {RESOURCE_NAME}_RESPAWN_TIME_SECS: u64 = 900; // 15 minutes
pub const {RESOURCE_NAME}_RADIUS: f32 = BASE_RESOURCE_RADIUS;
pub const {RESOURCE_NAME}_DENSITY_PERCENT: f32 = 0.3; // Adjust spawn density

// Minimum distance constants for spawning
pub const MIN_{RESOURCE_NAME}_DISTANCE_SQ: f32 = ({RESOURCE_NAME}_RADIUS * 2.0 + 50.0) * ({RESOURCE_NAME}_RADIUS * 2.0 + 50.0);
pub const MIN_{RESOURCE_NAME}_TREE_DISTANCE_SQ: f32 = ({RESOURCE_NAME}_RADIUS + crate::tree::TREE_RADIUS + 50.0) * ({RESOURCE_NAME}_RADIUS + crate::tree::TREE_RADIUS + 50.0);
pub const MIN_{RESOURCE_NAME}_STONE_DISTANCE_SQ: f32 = ({RESOURCE_NAME}_RADIUS + crate::stone::STONE_RADIUS + 50.0) * ({RESOURCE_NAME}_RADIUS + crate::stone::STONE_RADIUS + 50.0);

#[spacetimedb::reducer]
pub fn interact_with_{resource_name}(ctx: &ReducerContext, {resource_name}_id: u64) -> Result<(), String> {
    let sender_id = ctx.sender;

    // Find the {resource_name} entity
    let {resource_name}_entity = ctx.db.{resource_name}().id().find({resource_name}_id)
        .ok_or_else(|| format!("{ResourceName} with ID {} not found.", {resource_name}_id))?;

    // Validate player can interact (distance check, etc.)
    validate_player_resource_interaction(ctx, sender_id, {resource_name}_entity.pos_x, {resource_name}_entity.pos_y)?;

    // Check if resource is available (not respawning)
    if {resource_name}_entity.respawn_at.is_some() {
        return Err("{ResourceName} is not ready to be harvested.".to_string());
    }

    // Collect primary resource
    let mut rng = rand::thread_rng();
    let primary_amount = rng.gen_range({RESOURCE_NAME}_YIELD_AMOUNT_MIN..={RESOURCE_NAME}_YIELD_AMOUNT_MAX);
    
    collect_resource_and_schedule_respawn(
        ctx,
        sender_id,
        {resource_name}_id,
        {RESOURCE_NAME}_YIELD_ITEM_NAME.to_string(),
        primary_amount,
        {RESOURCE_NAME}_RESPAWN_TIME_SECS,
        |db_{resource_name}_table, id_to_update, respawn_timestamp| {
            if let Some(mut resource) = db_{resource_name}_table.id().find(id_to_update) {
                resource.respawn_at = Some(respawn_timestamp);
                db_{resource_name}_table.id().update(resource);
                Ok(())
            } else {
                Err(format!("Failed to find {resource_name} {} to mark for respawn.", id_to_update))
            }
        },
        |{resource_name}_table_handle| {resource_name}_table_handle.id()
    )?;

    // Optional: Collect secondary resource with chance
    if rng.gen::<f32>() < {RESOURCE_NAME}_SECONDARY_CHANCE {
        let secondary_amount = rng.gen_range({RESOURCE_NAME}_SECONDARY_AMOUNT_MIN..={RESOURCE_NAME}_SECONDARY_AMOUNT_MAX);
        if let Err(e) = crate::items::add_item_to_player_inventory(ctx, sender_id, {RESOURCE_NAME}_SECONDARY_ITEM_NAME, secondary_amount) {
            log::warn!("Failed to give secondary item {}: {}", {RESOURCE_NAME}_SECONDARY_ITEM_NAME, e);
        } else {
            log::info!("Player {} received {} {} as secondary yield", sender_id, secondary_amount, {RESOURCE_NAME}_SECONDARY_ITEM_NAME);
        }
    }

    log::info!("Player {} collected {resource_name} {} (primary: {}, secondary chance applied)", sender_id, {resource_name}_id, primary_amount);
    Ok(())
}
```

#### 1.2 Register Module (`server/src/lib.rs`)

Add these two lines in the appropriate sections:

```rust
// In module declarations section
mod {resource_name}; // Added for {ResourceName} resource

// In table trait imports section  
use crate::{resource_name}::{resource_name} as {ResourceName}TableTrait; // Added for {ResourceName} resource
```

#### 1.3 Update Environment System (`server/src/environment.rs`)

Add import:
```rust
use crate::{resource_name};
use crate::{resource_name}::{resource_name} as {ResourceName}TableTrait;
```

In `seed_environment` function, add seeding logic (find the pattern from existing resources):
```rust
let target_{resource_name}_count = (total_tiles as f32 * crate::{resource_name}::{RESOURCE_NAME}_DENSITY_PERCENT) as u32;
let max_{resource_name}_attempts = target_{resource_name}_count * crate::tree::MAX_TREE_SEEDING_ATTEMPTS_FACTOR;
let mut spawned_{resource_name}_positions = Vec::<(f32, f32)>::new();
let mut spawned_{resource_name}_count = 0;
let mut {resource_name}_attempts = 0;

log::info!("Target {ResourceName}s: {}, Max Attempts: {}", target_{resource_name}_count, max_{resource_name}_attempts);

// Add spawn location validation function if needed (e.g., for reeds: is_reed_location_suitable(ctx, pos_x, pos_y)
while spawned_{resource_name}_count < target_{resource_name}_count && {resource_name}_attempts < max_{resource_name}_attempts {
    {resource_name}_attempts += 1;
    match attempt_single_spawn(
        &mut rng,
        &mut occupied_tiles,
        &mut spawned_{resource_name}_positions,
        &spawned_tree_positions,
        &spawned_stone_positions,
        min_tile_x, max_tile_x, min_tile_y, max_tile_y,
        ctx.db.{resource_name}(),
        crate::{resource_name}::{RESOURCE_NAME}_RADIUS,
        crate::{resource_name}::MIN_{RESOURCE_NAME}_DISTANCE_SQ,
        crate::{resource_name}::MIN_{RESOURCE_NAME}_TREE_DISTANCE_SQ,
        crate::{resource_name}::MIN_{RESOURCE_NAME}_STONE_DISTANCE_SQ,
        noise_threshold, // Adjust as needed
        |pos_x, pos_y, chunk_index| {
            // Add custom location validation here if needed
            // e.g., for reeds: is_reed_location_suitable(ctx, pos_x, pos_y)
            true
        },
        |pos_x, pos_y, chunk_index| crate::{resource_name}::{ResourceName} {
            id: 0,
            pos_x,
            pos_y,
            chunk_index,
            respawn_at: None,
        }
    ) {
        Ok(_) => { spawned_{resource_name}_count += 1; }
        Err(_) => {} // Continue trying
    }
}

log::info!("Finished seeding {} {resource_name}s (target: {}, attempts: {}).", 
    spawned_{resource_name}_count, target_{resource_name}_count, {resource_name}_attempts);
```

In `check_resource_respawns` function, add respawn logic:
```rust
// Respawn {ResourceName}s
check_and_respawn_resource!(
    ctx,
    {resource_name}, // Table symbol
    crate::{resource_name}::{ResourceName}, // Entity type
    "{ResourceName}", // Name for logging
    |_r: &crate::{resource_name}::{ResourceName}| true, // Filter: Always check if respawn_at is set
    |r: &mut crate::{resource_name}::{ResourceName}| {
        r.respawn_at = None;
    }
);
```

### Step 2: Generate Client Bindings

**CRITICAL:** Run this command after server changes:
```bash
spacetime generate --lang typescript --out-dir ./client/src/generated --project-path ./server
```

### Step 3: Client-side Implementation

#### 3.1 Update Resource Types (`client/src/types/resourceTypes.ts`)

Add to imports:
```typescript
import { /* existing imports */, {ResourceName} } from '../generated';
```

Add to union type:
```typescript
export type HarvestableResource = /* existing types */ | {ResourceName};
export type ResourceType = /* existing types */ | '{resource_name}';
```

Add type guard function:
```typescript
export function is{ResourceName}(entity: any): entity is {ResourceName} {
    return entity && 
           typeof entity.posX === 'number' &&
           typeof entity.posY === 'number' &&
           typeof entity.id !== 'undefined' &&
           typeof entity.chunkIndex === 'number' &&
           (entity.respawnAt === null || entity.respawnAt instanceof Date || typeof entity.respawnAt === 'undefined') &&
           // Add specific distinguishing properties if needed
           (entity.__resourceType === '{resource_name}' || 
            (entity.hasOwnProperty('posX') && !entity.hasOwnProperty('health')));
}
```

Update functions:
```typescript
export function isHarvestableResource(entity: any): entity is TypedHarvestableResource {
  return /* existing checks */ || is{ResourceName}(entity);
}

export function getResourceType(entity: HarvestableResource): ResourceType {
  // Add to existing checks
  if (is{ResourceName}(entity)) return '{resource_name}';
  // ... existing code
}
```

#### 3.2 Configure Resource (`client/src/utils/renderers/resourceConfigurations.ts`)

Add image import:
```typescript
import {resource_name}ImageSource from '../../assets/doodads/{resource_name}.png';
```

Add to `RESOURCE_CONFIGS`:
```typescript
{resource_name}: {
  imageSource: {resource_name}ImageSource,
  targetWidth: 58, // Adjust size as needed
  shadowConfig: {
    maxStretchFactor: 2.2,
    shadowBlur: 10,
    pivotYOffset: 0.25,
    opacity: 0.4
  },
  interactionLabel: "Press E to Harvest {Resource Display Name}",
  harvestAmount: { min: 2, max: 4 },
  fallbackColor: '#228B22'
  // No animation config - static resource
},
```

#### 3.3 Add Renderer (`client/src/utils/renderers/unifiedResourceRenderer.ts`)

Add import:
```typescript
import { /* existing imports */, render{ResourceName} } from './unifiedResourceRenderer';
```

Add render function:
```typescript
export function render{ResourceName}(
  ctx: CanvasRenderingContext2D,
  {resource_name}: HarvestableResource,
  nowMs: number,
  cycleProgress: number,
  onlyDrawShadow?: boolean,
  skipDrawingShadow?: boolean
) {
  renderHarvestableResourceWithType(ctx, {resource_name}, '{resource_name}', nowMs, cycleProgress, onlyDrawShadow, skipDrawingShadow);
}
```

#### 3.4 Update Rendering Pipeline (`client/src/utils/renderers/renderingUtils.ts`)

Add import:
```typescript
import { /* existing imports */, render{ResourceName} } from './unifiedResourceRenderer';
```

Add rendering case in first pass:
```typescript
} else if (type === '{resource_name}') {
    render{ResourceName}(ctx, entity as any, nowMs, cycleProgress);
```

Add to second pass:
```typescript
} else if (type === '{resource_name}') {
    // {ResourceName} is fully rendered in the first pass - no second pass needed
```

#### 3.5 Update State Management (`client/src/hooks/useSpacetimeTables.ts`)

Add to state interface:
```typescript
{resource_name}s: Map<string, SpacetimeDB.{ResourceName}>;
```

Add state initialization:
```typescript
const [{resource_name}s, set{ResourceName}s] = useState<Map<string, SpacetimeDB.{ResourceName}>>(() => new Map());
```

Add subscription handlers:
```typescript
// --- {ResourceName} Subscriptions ---
const handle{ResourceName}Insert = (ctx: any, {resource_name}: SpacetimeDB.{ResourceName}) => set{ResourceName}s(prev => new Map(prev).set({resource_name}.id.toString(), {resource_name}));
const handle{ResourceName}Update = (ctx: any, old{ResourceName}: SpacetimeDB.{ResourceName}, new{ResourceName}: SpacetimeDB.{ResourceName}) => {
    const changed = old{ResourceName}.posX !== new{ResourceName}.posX ||
                    old{ResourceName}.posY !== new{ResourceName}.posY ||
                    old{ResourceName}.respawnAt !== new{ResourceName}.respawnAt;
    if (changed) {
        set{ResourceName}s(prev => new Map(prev).set(new{ResourceName}.id.toString(), new{ResourceName}));
    }
};
const handle{ResourceName}Delete = (ctx: any, {resource_name}: SpacetimeDB.{ResourceName}) => set{ResourceName}s(prev => { const newMap = new Map(prev); newMap.delete({resource_name}.id.toString()); return newMap; });
```

Add to connection event handlers:
```typescript
connection.db.{resource_name}.onInsert(handle{ResourceName}Insert); 
connection.db.{resource_name}.onUpdate(handle{ResourceName}Update); 
connection.db.{resource_name}.onDelete(handle{ResourceName}Delete);
```

Add to queries:
```typescript
const farmingQueries = [
    /* existing queries */,
    `SELECT * FROM {resource_name} WHERE chunk_index = ${chunkIndex}`
];
```

Add to return statement:
```typescript
{resource_name}s,
```

#### 3.6 Update Data Flow - App.tsx (`client/src/App.tsx`)

Add to destructuring:
```typescript
const { 
  /* existing destructuring */,
  {resource_name}s,
  /* rest of destructuring */
} = useSpacetimeTables();
```

Add to GameScreen props:
```typescript
{resource_name}s={{resource_name}s}
```

#### 3.7 Update Data Flow - GameScreen.tsx (`client/src/components/GameScreen.tsx`)

Add to imports:
```typescript
{ResourceName} as SpacetimeDB{ResourceName},
```

Add to interface:
```typescript
{resource_name}s: Map<string, SpacetimeDB{ResourceName}>;
```

Add to destructuring:
```typescript
{resource_name}s,
```

Add to GameCanvas props:
```typescript
{resource_name}s={{resource_name}s}
```

#### 3.8 Update Data Flow - GameCanvas.tsx (`client/src/components/GameCanvas.tsx`)

Add to imports:
```typescript
{ResourceName} as SpacetimeDB{ResourceName},
```

Add to interface:
```typescript
{resource_name}s: Map<string, SpacetimeDB{ResourceName}>;
```

Add to destructuring:
```typescript
{resource_name}s,
```

Add to useEntityFiltering call:
```typescript
{resource_name}s,
```

Add to useInteractionFinder destructuring:
```typescript
closestInteractable{ResourceName}Id,
```

Add to useInputHandler call:
```typescript
closestInteractable{ResourceName}Id,
```

Add to renderInteractionLabels call:
```typescript
{resource_name}s: visible{ResourceName}sMap,
closestInteractable{ResourceName}Id,
```

#### 3.9 Update Entity Filtering (`client/src/hooks/useEntityFiltering.ts`)

Add to imports:
```typescript
{ResourceName} as SpacetimeDB{ResourceName},
```

Add to type union:
```typescript
| { type: '{resource_name}'; entity: SpacetimeDB{ResourceName} }
```

Add to imports from type guards:
```typescript
is{ResourceName},
```

Add to props interface:
```typescript
{resource_name}s: Map<string, SpacetimeDB{ResourceName}>,
```

Add to filtering logic:
```typescript
const visible{ResourceName}s = useMemo(() => 
  {resource_name}s ? Array.from({resource_name}s.values())
    .filter(e => isEntityInView(e, viewBounds, currentTime) && !e.respawnAt)
    : []
, [{resource_name}s, isEntityInView, viewBounds, currentTime]);
```

Add to Y-sorted entities:
```typescript
...visible{ResourceName}s.map(r => ({ type: '{resource_name}' as const, entity: r })),
```

Add to return interface:
```typescript
visible{ResourceName}s: SpacetimeDB{ResourceName}[];
```

Add to return statement:
```typescript
visible{ResourceName}s,
visible{ResourceName}sMap: new Map(visible{ResourceName}s.map(r => [r.id.toString(), r])),
```

Add to isEntityInView function:
```typescript
} else if (is{ResourceName}(entity)) {
  x = entity.posX;
  y = entity.posY;
  width = 32;
  height = 76; // Adjust height as needed
```

Add to getSortY function:
```typescript
if (/* existing checks */ || is{ResourceName}(entity) /* other checks */) {
  // These are ground-level resources
  sortY = entity.posY;
  return sortY;
}
```

Add to dependencies:
```typescript
visible{ResourceName}s,
```

#### 3.10 Update Type Guards (`client/src/utils/typeGuards.ts`)

Add import:
```typescript
{ResourceName} as SpacetimeDB{ResourceName},
```

Add type guard function:
```typescript
// Type guard for {ResourceName}
export function is{ResourceName}(entity: any): entity is SpacetimeDB{ResourceName} {
    const result = entity && 
           typeof entity.posX === 'number' && 
           typeof entity.posY === 'number' && 
           typeof entity.id !== 'undefined' && 
           // Ensure it doesn't match other resource types or entities
           typeof entity.identity === 'undefined' && // Not a Player
           typeof entity.treeType === 'undefined' && // Not a Tree
           typeof entity.health === 'undefined' && // Not a Stone (or other entities with health like Player)
           typeof entity.placedBy === 'undefined' && // Not a Campfire, Box, or SleepingBag
           typeof entity.itemDefId === 'undefined' && // Not a DroppedItem
           typeof entity.isBurning === 'undefined' && // Not a Campfire
           typeof entity.chunkIndex === 'number' && 
           (entity.respawnAt === null || entity.respawnAt instanceof Date || typeof entity.respawnAt === 'undefined');
    
    return result;
}
```

#### 3.11 Update Interaction Finding (`client/src/hooks/useInteractionFinder.ts`)

Add import:
```typescript
{ResourceName} as SpacetimeDB{ResourceName},
```

Add distance constant:
```typescript
const PLAYER_{RESOURCE_NAME}_INTERACTION_DISTANCE_SQUARED = 120.0 * 120.0;
```

Add visual height constant:
```typescript
export const {RESOURCE_NAME}_VISUAL_HEIGHT_FOR_INTERACTION = 76;
```

Add to props interface:
```typescript
{resource_name}s: Map<string, SpacetimeDB{ResourceName}>;
```

Add to result interface:
```typescript
closestInteractable{ResourceName}Id: bigint | null;
```

Add state:
```typescript
const [closestInteractable{ResourceName}Id, setClosestInteractable{ResourceName}Id] = useState<bigint | null>(null);
```

Add to useMemo variables:
```typescript
let closest{ResourceName}Id: bigint | null = null;
let closest{ResourceName}DistSq = PLAYER_{RESOURCE_NAME}_INTERACTION_DISTANCE_SQUARED;
```

Add finding logic:
```typescript
// Find closest {resource_name}
if ({resource_name}s) {
    {resource_name}s.forEach(({resource_name}) => {
        if ({resource_name}.respawnAt !== null && {resource_name}.respawnAt !== undefined) return;
        const visualCenterY = {resource_name}.posY - (76 / 2);
        const dx = playerX - {resource_name}.posX;
        const dy = playerY - visualCenterY;
        const distSq = dx * dx + dy * dy;
        if (distSq < closest{ResourceName}DistSq) {
            closest{ResourceName}DistSq = distSq;
            closest{ResourceName}Id = {resource_name}.id;
        }
    });
}
```

Add to return statement:
```typescript
closestInteractable{ResourceName}Id,
```

Add to useEffect:
```typescript
if (interactionResult.closestInteractable{ResourceName}Id !== closestInteractable{ResourceName}Id) {
    setClosestInteractable{ResourceName}Id(interactionResult.closestInteractable{ResourceName}Id);
}
```

Add to final return:
```typescript
closestInteractable{ResourceName}Id,
```

Add to dependencies:
```typescript
{resource_name}s,
```

#### 3.12 Update Input Handling (`client/src/hooks/useInputHandler.ts`)

Add to props interface:
```typescript
closestInteractable{ResourceName}Id: bigint | null;
```

Add to destructuring:
```typescript
closestInteractable{ResourceName}Id,
```

Add to refs:
```typescript
{resource_name}: null as bigint | null,
```

Add to useEffect:
```typescript
{resource_name}: closestInteractable{ResourceName}Id,
```

Add to dependencies:
```typescript
closestInteractable{ResourceName}Id,
```

Add to tap action handling:
```typescript
const RETAINED_CLOSEST_{RESOURCE_NAME}_ID = closestIdsRef.current.{resource_name};

// In the interaction logic:
} else if (RETAINED_CLOSEST_{RESOURCE_NAME}_ID !== null) {
    console.log('[E-Tap ACTION] Harvesting {resource_name}:', RETAINED_CLOSEST_{RESOURCE_NAME}_ID);
    connectionRef.current.reducers.interactWith{ResourceName}(RETAINED_CLOSEST_{RESOURCE_NAME}_ID);
    tapActionTaken = true;
```

#### 3.13 Update Interaction Labels (`client/src/utils/renderers/labelRenderingUtils.ts`)

Add import:
```typescript
{ResourceName} as SpacetimeDB{ResourceName},
```

Add visual height import:
```typescript
{RESOURCE_NAME}_VISUAL_HEIGHT_FOR_INTERACTION,
```

Add to interface:
```typescript
{resource_name}s: Map<string, SpacetimeDB{ResourceName}>;
closestInteractable{ResourceName}Id: bigint | null;
```

Add to destructuring:
```typescript
{resource_name}s,
closestInteractable{ResourceName}Id,
```

Add label rendering:
```typescript
// {ResourceName} Label
if (closestInteractable{ResourceName}Id !== null) {
    const {resource_name} = {resource_name}s.get(closestInteractable{ResourceName}Id.toString());
    if ({resource_name}) {
        const text = getResourceInteractionLabel('{resource_name}');
        const visualCenterY = {resource_name}.posY - ({RESOURCE_NAME}_VISUAL_HEIGHT_FOR_INTERACTION / 2);
        const textX = {resource_name}.posX;
        const textY = visualCenterY - 30; // Offset above visual center
        ctx.strokeText(text, textX, textY);
        ctx.fillText(text, textX, textY);
    }
}
```

---

## Testing Checklist

After implementation, verify:

- [ ] **Server Builds:** `spacetime build --project-path ./server` succeeds
- [ ] **Client Bindings Generated:** Run `spacetime generate --lang typescript --out-dir ./client/src/generated --project-path ./server`
- [ ] **Resources Spawn:** Resources appear on the map after world generation
- [ ] **Visual Rendering:** Resources display correctly with proper shadows
- [ ] **Interaction Detection:** "Press E to Harvest" label appears when close
- [ ] **Harvesting Works:** E key successfully harvests and gives items
- [ ] **Respawning Works:** Resources reappear after the respawn timer
- [ ] **No Console Errors:** Check browser console for any TypeScript or rendering errors

---

## Common Issues & Solutions

### TypeScript Errors
- **"Property '{resource_name}' does not exist"** → Run `spacetime generate` after server changes
- **"Type 'string' is not assignable to ResourceType"** → Add `as const` to type assignments
- **"Cannot find name 'visible{ResourceName}sMap'"** → Check entity filtering return statement

### Rendering Issues  
- **Resource not visible** → Check seeding logic in environment.rs
- **Interaction not working** → Verify all input handling steps completed
- **Labels not showing** → Check that resource is added to labelRenderingUtils.ts

### Performance
- **Frame drops** → Ensure second pass rendering is handled correctly in renderingUtils.ts
- **Memory leaks** → Verify state cleanup in useSpacetimeTables.ts

---

This streamlined guide reduces resource addition time from hours to under 30 minutes by providing exact patterns and file locations. Each step has been tested with the Common Reed Stalk implementation.


